import{_ as M,p as S,s as k,q as Y,v as q,x as $,y as N,c as y,o as f,a as b,z as C,j as z,F as _,r as w,b as A}from"./u4BT2a0N.js";const x={idle:{color:{r:0,g:243,b:255},rotationSpeedY:0,rotationSpeedX:.001,squishY:1,glow:4,pulseSpeed:.03,pulseAmp:5},thinking:{color:{r:176,g:38,b:255},rotationSpeedY:.007,rotationSpeedX:.005,squishY:.95,glow:8,pulseSpeed:.1,pulseAmp:2},error:{color:{r:255,g:0,b:64},rotationSpeedY:0,rotationSpeedX:0,squishY:.4,glow:2,pulseSpeed:0,pulseAmp:0}},m=(h,t,e)=>h+(t-h)*e,R=(h,t,e)=>`rgb(${Math.round(h)}, ${Math.round(t)}, ${Math.round(e)})`,X=h=>new Promise(t=>setTimeout(t,h));class O{constructor({baseRadius:t,nodeCount:e}){this.baseRadius=t,this.nodeCount=e,this.angleX=0,this.angleY=0,this.time=0,this.baseNodes=[],this.current={rgb:{...x.idle.color},squish:1,colorString:"#00f3ff"},this.overrides={active:!1,color:null,squishY:null,pulseAmp:null,rotationSpeedY:null,radiusModifier:0},this.initNodes()}initNodes(){this.baseNodes=[];for(let t=0;t<this.nodeCount;t++){const e=Math.random()*2*Math.PI,o=Math.acos(Math.random()*2-1);this.baseNodes.push({x:Math.sin(o)*Math.cos(e),y:Math.sin(o)*Math.sin(e),z:Math.cos(o),sizeOffset:Math.random()})}}updateParams({nodeCount:t,baseRadius:e}){e&&(this.baseRadius=e),t&&t!==this.nodeCount&&(this.nodeCount=t,this.initNodes())}tick(t){this.time+=1;const e=x[t]||x.idle,o={color:this.overrides.active&&this.overrides.color?this.overrides.color:e.color,rotationSpeedX:e.rotationSpeedX,rotationSpeedY:this.overrides.active&&this.overrides.rotationSpeedY!==null?this.overrides.rotationSpeedY:e.rotationSpeedY,squishY:this.overrides.active&&this.overrides.squishY!==null?this.overrides.squishY:e.squishY,glow:e.glow,pulseSpeed:e.pulseSpeed,pulseAmp:this.overrides.active&&this.overrides.pulseAmp!==null?this.overrides.pulseAmp:e.pulseAmp};this.current.rgb.r=m(this.current.rgb.r,o.color.r,.1),this.current.rgb.g=m(this.current.rgb.g,o.color.g,.1),this.current.rgb.b=m(this.current.rgb.b,o.color.b,.1),this.current.colorString=R(this.current.rgb.r,this.current.rgb.g,this.current.rgb.b),this.current.squish=m(this.current.squish,o.squishY,.1),this.overrides.radiusModifier=m(this.overrides.radiusModifier,0,.15),this.angleX+=o.rotationSpeedX,this.angleY+=o.rotationSpeedY;const a=Math.sin(this.time*o.pulseSpeed)*o.pulseAmp,i=this.baseRadius+a+this.overrides.radiusModifier,s=this._projectNodes(i),r=this._calculateConnections(s,i);return{nodes:s,connections:r,style:{color:this.current.colorString,glow:this.current.rgb},glowStrength:o.glow}}_projectNodes(t){const e=Math.sin(this.angleX),o=Math.cos(this.angleX),a=Math.sin(this.angleY),i=Math.cos(this.angleY);return this.baseNodes.map(s=>{let r=s.x*i-s.z*a,c=s.z*i+s.x*a,v=s.y*o-c*e;c=c*o+s.y*e;const p=r*t,u=v*t*this.current.squish,l=c*t,d=c*t,n=800,g=n/(n-d);return{x:p*g,y:u*g,z:l,rx:p,ry:u,rz:l,size:(1.5+s.sizeOffset)*g,opacity:Math.max(.1,(d+t)/(t*2))}})}_calculateConnections(t,e){const o=[],a=70*(e/200),i=a*a,s=t.length;for(let r=0;r<s;r++){let c=0;for(let v=r+1;v<s;v++){if(o.length>350)return o;if(c>3)continue;const p=t[r],u=t[v];if(Math.abs(p.x-u.x)>a||Math.abs(p.y-u.y)>a)continue;const l=(p.x-u.x)**2+(p.y-u.y)**2;if(l<i){const d=1-l/i;o.push({x1:p.x,y1:p.y,x2:u.x,y2:u.y,width:d*1.5,opacity:d*.6}),c++}}}return o}async executeSequence(t){this.overrides.active=!0;for(const e of t)e.type==="color"?this.overrides.color=e.value:e.type==="squish"?this.overrides.squishY=e.value:e.type==="talk"?this.overrides.radiusModifier=e.strength||30:e.type==="spin"&&(this.overrides.rotationSpeedY=e.speed),e.duration&&await X(e.duration);this.overrides.active=!1,this.overrides.color=null,this.overrides.squishY=null,this.overrides.rotationSpeedY=null,this.overrides.pulseAmp=null}}const T=["width","height"],F=["transform"],P=["x1","y1","x2","y2","stroke","stroke-width","opacity"],j=["cx","cy","r","fill","opacity"],E={__name:"NeuroOrb",props:{mode:{type:String,default:"idle"},baseRadius:{type:Number,default:200},nodeCount:{type:Number,default:150}},setup(h,{expose:t}){const e=h,o=S(1e3),a=S(800),i=S(null),s=k({nodes:[],connections:[],style:{color:"#00f3ff"},glowStrength:4});let r=null,c=null;const v=()=>{r&&(s.value=r.tick(e.mode),c=requestAnimationFrame(v))};t({executeSequence:l=>r==null?void 0:r.executeSequence(l)});const u=Y(()=>{if(!s.value||!s.value.style||!s.value.style.glow)return{};const{r:l,g:d,b:n}=s.value.style.glow,g=s.value.glowStrength||1;return{backgroundColor:`rgb(${l}, ${d}, ${n})`,boxShadow:`0 0 ${g*.4}px ${g*3}px rgba(${l}, ${d}, ${n}, 0.6)`}});return q(()=>{i.value&&(o.value=i.value.clientWidth,a.value=i.value.clientHeight),r=new O({baseRadius:e.baseRadius,nodeCount:e.nodeCount}),v()}),$(()=>{cancelAnimationFrame(c)}),N(()=>[e.nodeCount,e.baseRadius],([l,d])=>{r==null||r.updateParams({nodeCount:l,baseRadius:d})}),(l,d)=>(f(),y("div",{class:"orb-container",ref_key:"container",ref:i},[b("div",{class:"glow-layer",style:C(u.value)},null,4),(f(),y("svg",{class:"network-svg",width:o.value,height:a.value},[s.value?(f(),y("g",{key:0,transform:`translate(${o.value/2}, ${a.value/2})`},[(f(!0),y(_,null,w(s.value.connections,(n,g)=>(f(),y("line",{key:`c-${g}`,x1:n.x1,y1:n.y1,x2:n.x2,y2:n.y2,stroke:s.value.style.color,"stroke-width":n.width,opacity:n.opacity,"stroke-linecap":"round"},null,8,P))),128)),(f(!0),y(_,null,w(s.value.nodes,(n,g)=>(f(),y("circle",{key:`n-${g}`,cx:n.x,cy:n.y,r:n.size,fill:s.value.style.color,opacity:n.opacity},null,8,j))),128))],8,F)):z("",!0)],8,T))],512))}},B=M(E,[["__scopeId","data-v-298e0033"]]),I={class:"neural-background"},L={class:"controls"},D={__name:"NeuroOrbWrapper",setup(h){const t=S(null),e=S("idle"),o=i=>{e.value=i,console.log(`Mode set to: ${i}`)},a=async()=>{if(t.value){const i=[{type:"color",value:{r:255,g:255,b:0},duration:100},{type:"talk",strength:40,duration:150},{type:"talk",strength:10,duration:150}];await t.value.executeSequence(i)}else console.error("NeuroOrb ref is missing!")};return(i,s)=>(f(),y("div",I,[A(B,{ref_key:"neuroOrbRef",ref:t,mode:e.value},null,8,["mode"]),b("div",L,[b("button",{onClick:s[0]||(s[0]=r=>o("idle"))},"Idle"),b("button",{onClick:s[1]||(s[1]=r=>o("thinking"))},"Thinking"),b("button",{onClick:s[2]||(s[2]=r=>o("error"))},"Error"),b("button",{onClick:a},"Trigger Talk")])]))}};export{D as _};
